<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd">

    <bean id="baseQueryLogic" class="datawave.services.query.logic.BaseQueryLogic" abstract="true" >
        <!-- This is injected via java -->
        <property name="markingFunctions" ref="markingFunctions" />
        <!-- This is injected via java -->
        <property name="responseObjectFactory" ref="responseObjectFactory" />
    </bean>

    <!-- TODO: This has traditionally been included via MetadataHelperContext.xml -->
    <bean id="dateIndexHelperFactory" class="datawave.query.util.DateIndexHelperFactory" >
        <lookup-method name="createDateIndexHelper" bean="dateIndexHelper" />
    </bean>
    <bean id="dateIndexHelper" scope="prototype" class="datawave.query.util.DateIndexHelper" />

    <bean id="BaseEventQuery" parent="baseQueryLogic" class="datawave.query.tables.ShardQueryLogic" abstract="true">
        <property name="checkpointable" value="${datawave.query.logic.logics.BaseEventQuery.checkpointable}" />
        <property name="accumuloPassword" value="${datawave.query.logic.logics.BaseEventQuery.accumuloPassword}" />
        <property name="tableName" value="${datawave.query.logic.logics.BaseEventQuery.tableName}" />
        <property name="dateIndexTableName" value="${datawave.query.logic.logics.BaseEventQuery.dateIndexTableName}" />

        <!-- This is injected via java -->
        <property name="dateIndexHelperFactory" ref="dateIndexHelperFactory" />

        <property name="defaultDateTypeName" value="${datawave.query.logic.logics.BaseEventQuery.defaultDateTypeName}"/>
        <property name="metadataTableName" value="${datawave.query.logic.logics.BaseEventQuery.metadataTableName}" />

        <!-- This is injected via java -->
        <property name="metadataHelperFactory" ref="metadataHelperFactory" />

        <property name="indexTableName" value="${datawave.query.logic.logics.BaseEventQuery.indexTableName}" />
        <property name="reverseIndexTableName" value="${datawave.query.logic.logics.BaseEventQuery.reverseIndexTableName}" />
        <property name="maxResults" value="${datawave.query.logic.logics.BaseEventQuery.maxResults}" />
        <property name="queryThreads" value="${datawave.query.logic.logics.BaseEventQuery.queryThreads}" />
        <property name="indexLookupThreads" value="${datawave.query.logic.logics.BaseEventQuery.indexLookupThreads}" />
        <property name="dateIndexThreads" value="${datawave.query.logic.logics.BaseEventQuery.dateIndexThreads}" />
        <property name="fullTableScanEnabled" value="${datawave.query.logic.logics.BaseEventQuery.fullTableScanEnabled}" />
        <property name="includeDataTypeAsField" value="${datawave.query.logic.logics.BaseEventQuery.includeDataTypeAsField}" />
        <property name="disableIndexOnlyDocuments" value="${datawave.query.logic.logics.BaseEventQuery.disableIndexOnlyDocuments}" />
        <property name="indexOnlyFilterFunctionsEnabled" value="${datawave.query.logic.logics.BaseEventQuery.indexOnlyFilterFunctionsEnabled}" />
        <property name="includeHierarchyFields" value="${datawave.query.logic.logics.BaseEventQuery.includeHierarchyFields}" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <property name="hierarchyFieldOptions"  ref="baseEventQueryHierarchyFieldOptions" />

        <property name="baseIteratorPriority" value="${datawave.query.logic.logics.BaseEventQuery.baseIteratorPriority}" />
        <property name="maxIndexScanTimeMillis" value="${datawave.query.logic.logics.BaseEventQuery.maxIndexScanTimeMillis}" />
        <property name="collapseUids" value="${datawave.query.logic.logics.BaseEventQuery.collapseUids}" />
        <property name="collapseUidsThreshold" value="${datawave.query.logic.logics.BaseEventQuery.collapseUidsThreshold}"/>
        <property name="useEnrichers" value="${datawave.query.logic.logics.BaseEventQuery.useEnrichers}" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <property name="contentFieldNames" ref="baseEventQueryContentFieldNames" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <property name="realmSuffixExclusionPatterns" ref="baseEventQueryRealmSuffixExclusionPatterns" />

        <property name="minimumSelectivity" value="${datawave.query.logic.logics.BaseEventQuery.minimumSelectivity}" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <property name="enricherClassNames" ref="baseEventQueryEnricherClassNames" />

        <property name="useFilters" value="${datawave.query.logic.logics.BaseEventQuery.useFilters}" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <property name="filterClassNames" ref="baseEventQueryFilterClassNames" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <property name="filterOptions" ref="baseEventQueryFilterOptions" />

        <property name="auditType" value="${datawave.query.logic.logics.BaseEventQuery.auditType}" />
        <property name="logicDescription" value="${datawave.query.logic.logics.BaseEventQuery.logicDescription}" />
        <!-- Determines how many events in the global index lookup will be
        aggregated into a day range -->
        <property name="eventPerDayThreshold" value="${datawave.query.logic.logics.BaseEventQuery.eventPerDayThreshold}" />
        <!-- Determines how many shards in the global index lookup will be
        aggregated into a day range -->
        <property name="shardsPerDayThreshold" value="${datawave.query.logic.logics.BaseEventQuery.shardsPerDayThreshold}" />
        <!-- The max number of terms AFTER all expansions -->
        <property name="maxTermThreshold" value="${datawave.query.logic.logics.BaseEventQuery.maxTermThreshold}" />
        <!-- The max query depth -->
        <property name="maxDepthThreshold" value="${datawave.query.logic.logics.BaseEventQuery.maxDepthThreshold}" />
        <!-- The max unfielded (_ANYFIELD_) expansion per term -->
        <property name="maxUnfieldedExpansionThreshold" value="${datawave.query.logic.logics.BaseEventQuery.maxUnfieldedExpansionThreshold}" />
        <!-- The max value (regex or range) expansion -->
        <property name="maxValueExpansionThreshold" value="${datawave.query.logic.logics.BaseEventQuery.maxValueExpansionThreshold}" />
        <!-- The max value or list expansion for a single field before using an ivarator -->
        <property name="maxOrExpansionThreshold" value="${datawave.query.logic.logics.BaseEventQuery.maxOrExpansionThreshold}" />
        <!-- The max value or list expansion for a group of ranges against a single field before combining them in an ivarator -->
        <property name="maxOrRangeThreshold" value="${datawave.query.logic.logics.BaseEventQuery.maxOrRangeThreshold}" />
        <!-- The max value or list expansion for a single field using an FST ivarator -->
        <property name="maxOrExpansionFstThreshold" value="${datawave.query.logic.logics.BaseEventQuery.maxOrExpansionFstThreshold}" />
        <!-- The max number of splits to divide a range into for the ivarators.  They are run in a pool of threads controlled by the tserver.datawave.ivarator.threads accumulo configuration property which defaults to 100 (IteratorThreadPoolManager). -->
        <property name="maxFieldIndexRangeSplit" value="${datawave.query.logic.logics.BaseEventQuery.maxFieldIndexRangeSplit}" />
        <!-- The max number of sources that can be created across ivarators for one scan -->
        <property name="maxIvaratorSources" value="${datawave.query.logic.logics.BaseEventQuery.maxIvaratorSources}" />
        <!-- The max number of evaluation pipelines.  They are run in a pool of threads controlled by the tserver.datawave.evaluation.threads accumulo configuration property which defaults to 100 (IteratorThreadPoolManager). -->
        <property name="maxEvaluationPipelines" value="${datawave.query.logic.logics.BaseEventQuery.maxEvaluationPipelines}" />
        <!-- The max number of non-null evaluated results to cache on each tserver beyond the evaluation pipelines in queue -->
        <property name="maxPipelineCachedResults" value="${datawave.query.logic.logics.BaseEventQuery.maxPipelineCachedResults}" />
        <!-- the list of comma delimited hdfs configuration files something like file:///opt/datawave/hadoop-warehouse/conf/core-site.xml,file:///opt/datawave/hadoop-warehouse/conf/hdfs-site.xml-->
        <property name="hdfsSiteConfigURLs" value="${datawave.query.logic.logics.BaseEventQuery.hdfsSiteConfigURLs}" />
        <!-- the zookeeper configuration (could be something like file:///opt/datawave/zookeeper-warehouse/conf/zoo.cfg, or the zookeeper list (somehost1:2181,somehost2:2181,â€¦)-->
        <property name="zookeeperConfig" value="${datawave.query.logic.logics.BaseEventQuery.zookeeperConfig}" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <!-- the list of directories in which the ivarator puts its caches (selection always made on tserver side) -->
        <property name="ivaratorCacheDirConfigs" ref="baseEventQueryIvaratorCacheDirConfigs" />

        <!-- the hdfs location where FST's will be stored (see maxOrExpansionFstThreshold above) -->
        <property name="ivaratorFstHdfsBaseURIs" value ="${datawave.query.logic.logics.BaseEventQuery.ivaratorFstHdfsBaseURIs}" />
        <!-- the size after which a buffer is flushed to a file. -->
        <property name="ivaratorCacheBufferSize" value="${datawave.query.logic.logics.BaseEventQuery.ivaratorCacheBufferSize}" />
        <!-- the max number of open files in an ivarator -->
        <property name="ivaratorMaxOpenFiles" value="${datawave.query.logic.logics.BaseEventQuery.ivaratorMaxOpenFiles}" />
        <!-- the number of keys scanned after which the buffer is flushed to a file. -->
        <property name="ivaratorCacheScanPersistThreshold" value="${datawave.query.logic.logics.BaseEventQuery.ivaratorCacheScanPersistThreshold}" />
        <!-- the scan time after which the buffer is flushed to a file. -->
        <property name="ivaratorCacheScanTimeoutMinutes" value="${datawave.query.logic.logics.BaseEventQuery.ivaratorCacheScanTimeoutMinutes}" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <property name="eventQueryDataDecoratorTransformer" ref="baseEventQueryEventQueryDataDecoratorTransformer" />

        <property name="modelTableName" value="${datawave.query.logic.logics.BaseEventQuery.modelTableName}" />
        <property name="modelName" value="${datawave.query.logic.logics.BaseEventQuery.modelName}" />

        <!-- This is injected via QueryLogicFactoryConfiguration.java and configured via configuration properties -->
        <property name="querySyntaxParsers" ref="baseEventQuerySyntaxParsers" />

        <!-- This is injected via QueryLogicFactory.xml -->
        <property name="queryPlanner" ref="DefaultQueryPlanner" />

        <property name="sendTimingToStatsd" value="${datawave.query.logic.logics.BaseEventQuery.sendTimingToStatsd}" />
        <property name="collectQueryMetrics" value="${datawave.query.logic.logics.BaseEventQuery.collectQueryMetrics}" />
        <property name="logTimingDetails" value="${datawave.query.logic.logics.BaseEventQuery.logTimingDetails}" />
        <property name="statsdHost" value="${datawave.query.logic.logics.BaseEventQuery.statsdHost}" />
        <property name="statsdPort" value="${datawave.query.logic.logics.BaseEventQuery.statsdPort}" />

        <!-- This is injected via QueryLogicFactory.xml -->
        <property name="selectorExtractor" ref="DatawaveSelectorExtractor" />

        <property name="evaluationOnlyFields" value="${datawave.query.logic.logics.BaseEventQuery.evaluationOnlyFields}" />
        <property name="maxConcurrentTasks" value="${datawave.query.logic.logics.BaseEventQuery.maxConcurrentTasks}" />

        <!-- This is injected via BaseEventQueryConfiguration.java and configured via configuration properties -->
        <property name="requiredRoles" ref="baseEventQueryRequiredRoles" />
    </bean>

    <bean id="DefaultQueryPlanner" scope="prototype" class="datawave.query.planner.DefaultQueryPlanner" >
        <property name="compressOptionMappings" value="true" />
        <property name="queryModelProviderFactory" ref="queryModelProviderFactory" />
        <!-- the first integer arg is to define the number of ranges per batch -->
        <constructor-arg>
            <value>2611</value>
        </constructor-arg>
        <!-- the second boolean arg is to turn on/off the limiting of the batch scanners -->
        <constructor-arg>
            <value>true</value>
        </constructor-arg>
        <!--<lookup-method name="getQueryModelProvider" bean="metadataHelperQueryModelProvider" />-->
    </bean>

    <bean id="queryModelProviderFactory" class="datawave.query.planner.QueryModelProvider.Factory" >
        <lookup-method name="createQueryModelProvider" bean="metadataHelperQueryModelProvider" />
    </bean>

    <bean id="metadataHelperQueryModelProvider" scope="prototype" class="datawave.query.planner.MetadataHelperQueryModelProvider" />

    <!-- A list of lucene to jexl query functions -->
    <util:list id="allowedFunctions" value-type="datawave.query.language.functions.jexl.JexlQueryFunction">
        <bean class="datawave.query.language.functions.jexl.IsNull"/>
        <bean class="datawave.query.language.functions.jexl.IsNotNull"/>
        <bean class="datawave.query.language.functions.jexl.Include"/>
        <bean class="datawave.query.language.functions.jexl.Exclude"/>
        <bean class="datawave.query.language.functions.jexl.Text"/>
        <bean class="datawave.query.language.functions.jexl.GeoFunction"/>
        <bean class="datawave.query.language.functions.jexl.Loaded"/>
        <bean class="datawave.query.language.functions.jexl.DateFunction"/>
        <bean class="datawave.query.language.functions.jexl.OccurrenceFunction"/>
        <bean class="datawave.query.language.functions.jexl.MatchesInGroupFunction"/>
        <bean class="datawave.query.language.functions.jexl.MatchesInGroupLeft"/>
        <bean class="datawave.query.language.functions.jexl.GetAllMatches"/>
        <bean class="datawave.query.language.functions.jexl.MatchesAtLeastCountOf"/>
        <bean class="datawave.query.language.functions.jexl.TimeFunction"/>
        <bean class="datawave.query.language.functions.jexl.Jexl"/>
        <bean class="datawave.query.language.functions.jexl.Options"/>
        <bean class="datawave.query.language.functions.jexl.Unique"/>
        <bean class="datawave.query.language.functions.jexl.Geowave.Contains"/>
        <bean class="datawave.query.language.functions.jexl.Geowave.CoveredBy"/>
        <bean class="datawave.query.language.functions.jexl.Geowave.Covers"/>
        <bean class="datawave.query.language.functions.jexl.Geowave.Crosses"/>
        <bean class="datawave.query.language.functions.jexl.Geowave.Intersects"/>
        <bean class="datawave.query.language.functions.jexl.Geowave.Overlaps"/>
        <bean class="datawave.query.language.functions.jexl.Geowave.Within"/>
        <bean class="datawave.query.language.functions.jexl.EvaluationOnly">
            <property name="parser" ref="LuceneToJexlQueryParser"/>
        </bean>
    </util:list>

    <bean id="LuceneToJexlQueryParser" scope="prototype" class="datawave.query.language.parser.jexl.LuceneToJexlQueryParser">
        <!-- This is injected via QueryLogicFactoryConfiguration.java and configured via configuration properties -->
        <property name="skipTokenizeUnfieldedFields" ref="skipTokenizeUnfieldedFields"/>
        <!-- This is injected via QueryLogicFactory.xml -->
        <property name="allowedFunctions" ref="allowedFunctions"/>
    </bean>

    <bean id="LuceneToJexlUUIDQueryParser" scope="prototype" class="datawave.query.language.parser.jexl.LuceneToJexlUUIDQueryParser">
        <!-- This is injected via QueryLogicFactoryConfiguration.java and configured via configuration properties -->
        <property name="uuidTypes" ref="uuidTypes" />
        <!-- This is injected via QueryLogicFactory.xml -->
        <property name="allowedFunctions" ref="allowedFunctions"/>
    </bean>

    <bean id="TokenizedLuceneToJexlQueryParser" scope="prototype" class="datawave.query.language.parser.jexl.LuceneToJexlQueryParser">
        <property name="tokenizeUnfieldedQueries" value="true" />
        <!-- This is injected via QueryLogicFactoryConfiguration.java and configured via configuration properties -->
        <property name="skipTokenizeUnfieldedFields" ref="skipTokenizeUnfieldedFields"/>
        <!-- This is injected via QueryLogicFactoryConfiguration.java and configured via configuration properties -->
        <property name="tokenizedFields" ref="tokenizedFields"/>
        <!-- This is injected via QueryLogicFactory.xml -->
        <property name="allowedFunctions" ref="allowedFunctions"/>
    </bean>

    <bean id="DatawaveSelectorExtractor" scope="prototype" class="datawave.audit.DatawaveSelectorExtractor" />

    <bean id="EventQuery" scope="prototype"  parent="BaseEventQuery">
        <property name="logicDescription" value="Query the sharded event/document schema, leveraging the global index tables as needed" />
    </bean>

    <bean id="AltEventQuery" scope="prototype"  parent="BaseEventQuery">
        <property name="logicDescription" value="Query the sharded event/document schema, leveraging the global index tables as needed" />
    </bean>

    <!-- Query Logic that implements a discovery type query over the index -->
    <bean id="DiscoveryQuery" parent="baseQueryLogic" scope="prototype"  class="datawave.query.discovery.DiscoveryLogic">
        <property name="checkpointable" value="${datawave.query.logic.logics.DiscoveryQuery.checkpointable}" />
        <property name="tableName" value="${datawave.query.logic.logics.DiscoveryQuery.tableName}" />
        <property name="indexTableName" value="${datawave.query.logic.logics.DiscoveryQuery.indexTableName}" />
        <property name="reverseIndexTableName" value="${datawave.query.logic.logics.DiscoveryQuery.reverseIndexTableName}" />
        <property name="maxResults" value="${datawave.query.logic.logics.DiscoveryQuery.maxResults}" />
        <property name="maxWork" value="${datawave.query.logic.logics.DiscoveryQuery.maxWork}" />
        <property name="metadataTableName" value="${datawave.query.logic.logics.DiscoveryQuery.metadataTableName}" />
        <property name="modelTableName" value="${datawave.query.logic.logics.DiscoveryQuery.modelTableName}" />
        <property name="modelName" value="${datawave.query.logic.logics.DiscoveryQuery.modelName}" />
        <property name="metadataHelperFactory" ref="metadataHelperFactory" />
        <property name="fullTableScanEnabled" value="${datawave.query.logic.logics.DiscoveryQuery.fullTableScanEnabled}" />
        <property name="allowLeadingWildcard" value="${datawave.query.logic.logics.DiscoveryQuery.allowLeadingWildcard}" />
        <property name="auditType" value="${datawave.query.logic.logics.DiscoveryQuery.auditType}" />
        <property name="logicDescription" value="Discovery query that returns information from the index about the supplied term(s)" />
        <property name="selectorExtractor" ref="DatawaveSelectorExtractor" />
    </bean>

    <!-- begin original QueryLogicFactory.xml -->

    <!--    &lt;!&ndash;  part of what enforces any Required properties to be set on loading of the context &ndash;&gt;-->
    <!--    <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" />-->

    <!--    &lt;!&ndash; Database properties are retrieved from the database.properties file-->
    <!--        but can be overridden by system properties &ndash;&gt;-->
    <!--    <context:property-placeholder location="classpath:/datawave/query/database.properties" system-properties-mode="OVERRIDE" ignore-unresolvable="true" order="0" />-->

    <!--    &lt;!&ndash; A list of lucene to jexl query functions &ndash;&gt;-->
    <!--    <util:list id="allowedQueryFunctions" value-type="datawave.query.language.functions.jexl.JexlQueryFunction">-->
    <!--        <bean class="datawave.query.language.functions.jexl.IsNull"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.IsNotNull"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Include"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Exclude"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Text"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.GeoFunction"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Loaded"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.DateFunction"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.OccurrenceFunction"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.MatchesInGroupFunction"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.MatchesInGroupLeft"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.GetAllMatches"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.MatchesAtLeastCountOf"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.TimeFunction"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Jexl"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Options"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Unique"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Geowave.Contains"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Geowave.CoveredBy"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Geowave.Covers"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Geowave.Crosses"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Geowave.Intersects"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Geowave.Overlaps"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.Geowave.Within"/>-->
    <!--        <bean class="datawave.query.language.functions.jexl.EvaluationOnly">-->
    <!--            <property name="parser" ref="LuceneToJexlQueryParser"/>-->
    <!--        </bean>-->
    <!--    </util:list>-->

    <!--    &lt;!&ndash; Fields we should not tokenize in a tokenized query. In non-tokenized-->
    <!--         the field name is simply removed &ndash;&gt;-->
    <!--    <util:set id="skipTokenizeFields" value-type="java.lang.String">-->
    <!--        <value>DOMETA</value>-->
    <!--    </util:set>-->

    <!--    &lt;!&ndash; Fields we should tokenize in a tokenized query &ndash;&gt;-->
    <!--    <util:set id="tokenizeFields" value-type="java.lang.String">-->
    <!--        <value>CONTENT</value>-->
    <!--    </util:set>-->

    <!--    <bean id="LuceneToJexlQueryParser" scope="prototype" class="datawave.query.language.parser.jexl.LuceneToJexlQueryParser">-->
    <!--        <property name="skipTokenizeUnfieldedFields" ref="skipTokenizeFields"/>-->
    <!--        <property name="allowedFunctions" ref="allowedQueryFunctions"/>-->
    <!--    </bean>-->

    <!--    <bean id="LuceneToJexlUUIDQueryParser" scope="prototype" class="datawave.query.language.parser.jexl.LuceneToJexlUUIDQueryParser">-->
    <!--        <property name="uuidTypes" ref="UUIDTypeList" />-->
    <!--        <property name="allowedFunctions" ref="allowedQueryFunctions"/>-->
    <!--    </bean>-->

    <!--    <bean id="TokenizedLuceneToJexlQueryParser" scope="prototype" class="datawave.query.language.parser.jexl.LuceneToJexlQueryParser">-->
    <!--        <property name="tokenizeUnfieldedQueries" value="true" />-->
    <!--        <property name="skipTokenizeUnfieldedFields" ref="skipTokenizeFields"/>-->
    <!--        <property name="tokenizedFields" ref="tokenizeFields"/>-->
    <!--        <property name="allowedFunctions" ref="allowedQueryFunctions"/>-->
    <!--    </bean>-->

    <!--    <bean id="DefaultQueryPlanner" scope="prototype" class="datawave.query.planner.DefaultQueryPlanner" >-->
    <!--        <property name="compressOptionMappings" value="true" />-->
    <!--        <property name="queryModelProviderFactory" ref="queryModelProviderFactory" />-->
    <!--        &lt;!&ndash; the first integer arg is to define the number of ranges per batch &ndash;&gt;-->
    <!--        <constructor-arg>-->
    <!--            <value>2611</value>-->
    <!--        </constructor-arg>-->
    <!--        &lt;!&ndash; the second boolean arg is to turn on/off the limiting of the batch scanners &ndash;&gt;-->
    <!--        <constructor-arg>-->
    <!--            <value>true</value>-->
    <!--        </constructor-arg>-->
    <!--        &lt;!&ndash;<lookup-method name="getQueryModelProvider" bean="metadataHelperQueryModelProvider" />&ndash;&gt;-->
    <!--    </bean>-->

    <!--    <bean id="queryModelProviderFactory" class="datawave.query.planner.QueryModelProvider.Factory" >-->
    <!--        <lookup-method name="createQueryModelProvider" bean="metadataHelperQueryModelProvider" />-->
    <!--    </bean>-->

    <!--    <bean id="wiredQueryModelProvider" scope="prototype" class="datawave.query.planner.WiredQueryModelProvider" >-->
    <!--        <property name="queryModel">-->
    <!--            <util:map>-->
    <!--                ${lookup.uuid.mappings}-->
    <!--            </util:map>-->
    <!--        </property>-->

    <!--    </bean>-->

    <!--    <bean id="metadataHelperQueryModelProvider" scope="prototype" class="datawave.query.planner.MetadataHelperQueryModelProvider" />-->

    <!--    <bean id="BooleanChunkingQueryPlanner" scope="prototype" class="datawave.query.planner.BooleanChunkingQueryPlanner" />-->

    <!--    &lt;!&ndash; Begin SelectorExtractors for injection into query logics &ndash;&gt;-->

    <!--    <bean id="DatawaveSelectorExtractor" scope="prototype" class="datawave.audit.DatawaveSelectorExtractor" />-->

    <!--    &lt;!&ndash; End SelectorExtractors &ndash;&gt;-->
    <!--    <bean id="responseObjectFactory" class="datawave.services.query.result.event.DefaultResponseObjectFactory" />-->

    <!--    <bean id="baseQueryLogic" class="datawave.webservice.query.logic.BaseQueryLogic" abstract="true" >-->
    <!--        <property name="markingFunctions" ref="markingFunctions" />-->
    <!--        <property name="responseObjectFactory" ref="responseObjectFactory" />-->
    <!--    </bean>-->

    <!--    <bean id="BaseEventQuery" parent="baseQueryLogic" class="datawave.query.tables.ShardQueryLogic" abstract="true">-->
    <!--        <property name="accumuloPassword" value="${accumulo.user.password}" />-->
    <!--        <property name="tableName" value="${shard.table.name}" />-->
    <!--        <property name="dateIndexTableName" value="${date.index.table.name}" />-->
    <!--        <property name="dateIndexHelperFactory" ref="dateIndexHelperFactory" />-->
    <!--        <property name="defaultDateTypeName" value="${default.date.type.name}"/>-->
    <!--        <property name="metadataTableName" value="${metadata.table.name}" />-->
    <!--        <property name="metadataHelperFactory" ref="metadataHelperFactory" />-->
    <!--        <property name="indexTableName" value="${index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${rindex.table.name}" />-->
    <!--        <property name="maxResults" value="${event.query.max.results}" />-->
    <!--        <property name="queryThreads" value="${shard.query.threads}" />-->
    <!--        <property name="indexLookupThreads" value="${index.query.threads}" />-->
    <!--        <property name="dateIndexThreads" value="${date.index.threads}" />-->
    <!--        <property name="fullTableScanEnabled" value="${beq.fullTableScanEnabled}" />-->
    <!--        <property name="includeDataTypeAsField" value="false" />-->
    <!--        <property name="disableIndexOnlyDocuments" value="${disable.index.only.documents}" />-->
    <!--        <property name="indexOnlyFilterFunctionsEnabled" value="${enable.index.only.filter.functions}" />-->
    <!--        <property name="includeHierarchyFields" value="${include.hierarchy.fields}" />-->
    <!--        <property name="hierarchyFieldOptions"  ref="BaseEventQueryHierarchyFieldOptions" />-->
    <!--        <property name="baseIteratorPriority" value="${beq.baseIteratorPriority}" />-->
    <!--        <property name="maxIndexScanTimeMillis" value="${query.max.index.scan.ms}" />-->
    <!--        <property name="collapseUids" value="${query.collapse.uids}" />-->
    <!--        <property name="collapseUidsThreshold" value="${query.collapse.uids.threshold}"/>-->
    <!--        <property name="useEnrichers" value="true" />-->
    <!--        <property name="contentFieldNames">-->
    <!--            <list value-type="java.lang.String">-->
    <!--                <value>CONTENT</value>-->
    <!--            </list>-->
    <!--        </property>-->
    <!--        <property name="realmSuffixExclusionPatterns" >-->
    <!--            <list value-type="java.lang.String">-->
    <!--                <value>&lt;.*&gt;$</value>-->
    <!--            </list>-->
    <!--        </property>-->
    <!--        <property name="minimumSelectivity" value=".2" />-->
    <!--        <property name="enricherClassNames">-->
    <!--            <list value-type="java.lang.String">-->
    <!--                <value>datawave.query.enrich.DatawaveTermFrequencyEnricher</value>-->
    <!--            </list>-->
    <!--        </property>-->
    <!--        <property name="useFilters" value="${event.query.filters.enabled}" />-->
    <!--        <property name="filterClassNames">-->
    <!--            <list value-type="java.lang.String">-->
    <!--                ${event.query.filters.classnames}-->
    <!--            </list>-->
    <!--        </property>-->
    <!--        <property name="filterOptions" ref="BaseEventQueryFilterOptions" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="Retrieve sharded events/documents, leveraging the global index tables as needed" />-->
    <!--        &lt;!&ndash; Determines how many events in the global index lookup will be-->
    <!--        aggregated into a day range &ndash;&gt;-->
    <!--        <property name="eventPerDayThreshold" value="40000" />-->
    <!--        &lt;!&ndash; Determines how many shards in the global index lookup will be-->
    <!--        aggregated into a day range &ndash;&gt;-->
    <!--        <property name="shardsPerDayThreshold" value="${beq.shardsPerDayThreshold}" />-->
    <!--        &lt;!&ndash; The max number of terms AFTER all expansions &ndash;&gt;-->
    <!--        <property name="maxTermThreshold" value="${beq.maxTermThreshold}" />-->
    <!--        &lt;!&ndash; The max query depth &ndash;&gt;-->
    <!--        <property name="maxDepthThreshold" value="${beq.maxDepthThreshold}" />-->
    <!--        &lt;!&ndash; The max unfielded (_ANYFIELD_) expansion per term &ndash;&gt;-->
    <!--        <property name="maxUnfieldedExpansionThreshold" value="${beq.unfieldedExpansionThreshold}" />-->
    <!--        &lt;!&ndash; The max value (regex or range) expansion &ndash;&gt;-->
    <!--        <property name="maxValueExpansionThreshold" value="${beq.valueExpansionThreshold}" />-->
    <!--        &lt;!&ndash; The max value or list expansion for a single field before using an ivarator &ndash;&gt;-->
    <!--        <property name="maxOrExpansionThreshold" value="${beq.orExpansionThreshold}" />-->
    <!--        &lt;!&ndash; The max value or list expansion for a group of ranges against a single field before combining them in an ivarator &ndash;&gt;-->
    <!--        <property name="maxOrRangeThreshold" value="${beq.orRangeThreshold}" />-->
    <!--        &lt;!&ndash; The max value or list expansion for a single field using an FST ivarator &ndash;&gt;-->
    <!--        <property name="maxOrExpansionFstThreshold" value="${beq.orExpansionFstThreshold}" />-->
    <!--        &lt;!&ndash; The max number of splits to divide a range into for the ivarators.  They are run in a pool of threads controlled by the tserver.datawave.ivarator.threads accumulo configuration property which defaults to 100 (IteratorThreadPoolManager). &ndash;&gt;-->
    <!--        <property name="maxFieldIndexRangeSplit" value="${beq.fieldIndexRangeSplit}" />-->
    <!--        &lt;!&ndash; The max number of sources that can be created across ivarators for one scan &ndash;&gt;-->
    <!--        <property name="maxIvaratorSources" value="${beq.maxIvaratorSources}" />-->
    <!--        &lt;!&ndash; The max number of evaluation pipelines.  They are run in a pool of threads controlled by the tserver.datawave.evaluation.threads accumulo configuration property which defaults to 100 (IteratorThreadPoolManager). &ndash;&gt;-->
    <!--        <property name="maxEvaluationPipelines" value="${beq.evaluationPipelines}" />-->
    <!--        &lt;!&ndash; The max number of non-null evaluated results to cache on each tserver beyond the evaluation pipelines in queue &ndash;&gt;-->
    <!--        <property name="maxPipelineCachedResults" value="${beq.pipelineCachedResults}" />-->
    <!--        &lt;!&ndash; the list of comma delimited hdfs configuration files something like file:///opt/datawave/hadoop-warehouse/conf/core-site.xml,file:///opt/datawave/hadoop-warehouse/conf/hdfs-site.xml&ndash;&gt;-->
    <!--        <property name="hdfsSiteConfigURLs" value="${hdfs.site.config.urls}" />-->
    <!--        &lt;!&ndash; the zookeeper configuration (could be something like file:///opt/datawave/zookeeper-warehouse/conf/zoo.cfg, or the zookeeper list (somehost1:2181,somehost2:2181,â€¦)&ndash;&gt;-->
    <!--        <property name="zookeeperConfig" value="${ivarator.zookeeper.hosts}" />-->
    <!--        &lt;!&ndash; the list of directories in which the ivarator puts its caches (selection always made on tserver side) &ndash;&gt;-->
    <!--        <property name="ivaratorCacheDirConfigs" ref="IvaratorCacheDirConfigs" />-->
    <!--        &lt;!&ndash; the hdfs location where FST's will be stored (see maxOrExpansionFstThreshold above) &ndash;&gt;-->
    <!--        <property name="ivaratorFstHdfsBaseURIs" value ="${ivarator.fst.hdfs.base.uris}" />-->
    <!--        &lt;!&ndash; the size after which a buffer is flushed to a file. &ndash;&gt;-->
    <!--        <property name="ivaratorCacheBufferSize" value="10000" />-->
    <!--        &lt;!&ndash; the max number of open files in an ivarator &ndash;&gt;-->
    <!--        <property name="ivaratorMaxOpenFiles" value="${beq.maxIvaratorOpenFiles}" />-->
    <!--        &lt;!&ndash; the number of keys scanned after which the buffer is flushed to a file. &ndash;&gt;-->
    <!--        <property name="ivaratorCacheScanPersistThreshold" value="100000" />-->
    <!--        &lt;!&ndash; the scan time after which the buffer is flushed to a file. &ndash;&gt;-->
    <!--        <property name="ivaratorCacheScanTimeoutMinutes" value="${query.max.call.time.minutes}" />-->
    <!--        <property name="eventQueryDataDecoratorTransformer" ref="EventQueryDataDecoratorTransformer" />-->
    <!--        <property name="modelTableName" value="${metadata.table.name}" />-->
    <!--        <property name="modelName" value="DATAWAVE" />-->
    <!--        <property name="querySyntaxParsers">-->
    <!--            <map key-type="java.lang.String" value-type="datawave.query.language.parser.QueryParser">-->
    <!--                <entry key="JEXL">-->
    <!--                    <null/>-->
    <!--                </entry>-->
    <!--                <entry key="LUCENE" value-ref="LuceneToJexlQueryParser" />-->
    <!--                <entry key="LUCENE-UUID" value-ref="LuceneToJexlUUIDQueryParser" />-->
    <!--                <entry key="TOKENIZED-LUCENE" value-ref="TokenizedLuceneToJexlQueryParser" />-->
    <!--                &lt;!&ndash; JEXL is the default Jexl query syntax &ndash;&gt;-->
    <!--            </map>-->
    <!--        </property>-->
    <!--        <property name="queryPlanner" ref="DefaultQueryPlanner" />-->
    <!--        <property name="sendTimingToStatsd" value="false" />-->
    <!--        <property name="collectQueryMetrics" value="true" />-->
    <!--        <property name="logTimingDetails" value="false" />-->
    <!--        <property name="statsdHost" value="localhost" />-->
    <!--        <property name="statsdPort" value="8125" />-->
    <!--        <property name="selectorExtractor" ref="DatawaveSelectorExtractor" />-->
    <!--        <property name="evaluationOnlyFields" value="${evaluation.only.fields}" />-->
    <!--    </bean>-->

    <!--    <util:list id="IvaratorCacheDirConfigs">-->
    <!--        ${ivarator.cache.dir.config}-->
    <!--    </util:list>-->

    <!--    <util:map id="BaseEventQueryFilterOptions">-->
    <!--        ${event.query.filters.options}-->
    <!--    </util:map>-->

    <!--    <util:map id="BaseEventQueryHierarchyFieldOptions" value-type="java.lang.String">-->
    <!--        ${hierarchy.field.options}-->
    <!--    </util:map>-->

    <!--    <bean id="BaseCountQuery" parent="BaseEventQuery" class="datawave.query.tables.CountingShardQueryLogic" abstract="true" />-->

    <!--    <bean id="BaseModelEventQuery" parent="BaseEventQuery" abstract="true">-->
    <!--        <property name="modelTableName" value="${metadata.table.name}" />-->
    <!--        <property name="modelName" value="DATAWAVE" />-->
    <!--    </bean>-->

    <!--    <bean id="EventQueryDataDecoratorTransformer" scope="prototype" class="datawave.query.transformer.EventQueryDataDecoratorTransformer">-->
    <!--        <property name="dataDecorators">-->
    <!--            <map key-type="java.lang.String"-->
    <!--                 value-type="datawave.query.transformer.EventQueryDataDecorator">-->
    <!--                ${event.query.data.decorators}-->
    <!--            </map>-->
    <!--        </property>-->
    <!--    </bean>-->

    <!--    <util:list id="UUIDTypeList" value-type="datawave.query.data.UUIDType">-->
    <!--        ${lookup.uuid.uuidTypes}-->
    <!--    </util:list>-->

    <!--    <bean id="LookupUUIDConfiguration" class="datawave.webservice.query.configuration.LookupUUIDConfiguration">-->
    <!--        <property name="uuidTypes" ref="UUIDTypeList" />-->
    <!--        <property name="columnVisibility" value="" />-->
    <!--        <property name="beginDate" value="${lookup.uuid.beginDate}" />-->
    <!--    </bean>-->

    <!--    <bean id="IdTranslatorConfiguration" class="datawave.webservice.query.configuration.IdTranslatorConfiguration">-->
    <!--        <property name="uuidTypes" ref="UUIDTypeList" />-->
    <!--        <property name="columnVisibility" value="" />-->
    <!--        <property name="beginDate" value="${lookup.uuid.beginDate}" />-->
    <!--    </bean>-->

    <!--    <bean id="QueryLogicFactoryConfiguration"-->
    <!--          class="datawave.webservice.query.logic.QueryLogicFactoryConfiguration">-->

    <!--        &lt;!&ndash; The max number of records (max pagesize value) &ndash;&gt;-->
    <!--        <property name="maxPageSize" value="${query.max.page.size}" />-->

    <!--        &lt;!&ndash; The number of bytes over which a page will be forced to be returned, even if the pagesize has not yet been attained &ndash;&gt;-->
    <!--        <property name="pageByteTrigger" value="${query.page.byte.trigger}" />-->

    <!--    </bean>-->

    <!--    &lt;!&ndash; Query Logic which performs a count on fieldIndex keys &ndash;&gt;-->
    <!--    <bean id="FieldIndexCountQuery" parent="baseQueryLogic" scope="prototype"  class="datawave.query.tables.shard.FieldIndexCountQueryLogic">-->
    <!--        <property name="tableName" value="${shard.table.name}" />-->
    <!--        <property name="indexTableName" value="${index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${rindex.table.name}" />-->
    <!--        <property name="metadataTableName" value="${metadata.table.name}" />-->
    <!--        <property name="metadataHelperFactory" ref="metadataHelperFactory" />-->
    <!--        <property name="maxResults" value="-1" />-->
    <!--        <property name="maxWork" value="-1" />-->
    <!--        <property name="queryThreads" value="${shard.query.threads}" />-->
    <!--        <property name="modelTableName" value="${metadata.table.name}" />-->
    <!--        <property name="modelName" value="DATAWAVE" />-->
    <!--        <property name="maxUniqueValues" value="20000" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="Indexed Fields Only:  Given FIELDNAME returns counts for each unique value. Given FIELDNAME:FIELDVALUE returns count for only that value." />-->
    <!--        <property name="selectorExtractor" ref="DatawaveSelectorExtractor" />-->
    <!--    </bean>-->

    <!--    &lt;!&ndash; Query Logic that returns document content &ndash;&gt;-->
    <!--    <bean id="ContentQuery" parent="baseQueryLogic" scope="prototype"  class="datawave.query.tables.content.ContentQueryTable">-->
    <!--        <property name="tableName" value="${shard.table.name}" />-->
    <!--        <property name="maxResults" value="-1" />-->
    <!--        <property name="maxWork" value="-1" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="Query that returns a document given the document identifier" />-->
    <!--    </bean>-->

    <!--    &lt;!&ndash; Query Logic that returns document term frequency information &ndash;&gt;-->
    <!--    <bean id="TermFrequencyQuery" parent="baseQueryLogic" scope="prototype"  class="datawave.query.tables.term.TermFrequencyQueryTable">-->
    <!--        <property name="tableName" value="${shard.table.name}" />-->
    <!--        <property name="maxResults" value="-1" />-->
    <!--        <property name="maxWork" value="-1" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="Query that returns data from the term frequency query table" />-->
    <!--    </bean>-->

    <!--    &lt;!&ndash; Query Logic which performs a count on error table fieldIndex keys &ndash;&gt;-->
    <!--    <bean id="ErrorFieldIndexCountQuery" parent="baseQueryLogic" scope="prototype"  class="datawave.query.tables.shard.FieldIndexCountQueryLogic">-->
    <!--        <property name="tableName" value="${error.shard.table.name}" />-->
    <!--        <property name="indexTableName" value="${error.index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${error.rindex.table.name}" />-->
    <!--        <property name="metadataTableName" value="${error.metadata.table.name}" />-->
    <!--        <property name="metadataHelperFactory" ref="metadataHelperFactory" />-->
    <!--        <property name="maxResults" value="-1" />-->
    <!--        <property name="maxWork" value="-1" />-->
    <!--        <property name="queryThreads" value="${shard.query.threads}" />-->
    <!--        <property name="modelTableName" value="${metadata.table.name}" />-->
    <!--        <property name="modelName" value="DATAWAVE" />-->
    <!--        <property name="maxUniqueValues" value="20000" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="FieldIndex count query (experimental)" />-->
    <!--        <property name="selectorExtractor" ref="DatawaveSelectorExtractor" />-->
    <!--    </bean>-->

    <!--    &lt;!&ndash; Query logic that returns events from the error table &ndash;&gt;-->
    <!--    <bean id="ErrorEventQuery" scope="prototype" parent="BaseEventQuery">-->
    <!--        <property name="logicDescription" value="Retrieve events/documents that encountered one or more errors during ingest" />-->
    <!--        <property name="tableName" value="${error.shard.table.name}" />-->
    <!--        <property name="metadataTableName" value="${error.metadata.table.name}" />-->
    <!--        <property name="dateIndexTableName" value="" />-->
    <!--        <property name="indexTableName" value="${error.index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${error.rindex.table.name}" />-->
    <!--        <property name="includeHierarchyFields" value="false" />-->
    <!--    </bean>-->

    <!--    <bean id="LuceneUUIDEventQuery" parent="baseQueryLogic" scope="prototype" class="datawave.webservice.query.logic.composite.CompositeQueryLogic">-->
    <!--        <property name="logicDescription" value="Composite query logic that retrieves records from the event and error tables, based on known UUID fields, ie, those configured via UUIDTypeList in QueryLogicFactory.xml" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="queryLogics">-->
    <!--            <list value-type="datawave.webservice.query.logic.BaseQueryLogic">-->
    <!--                <bean scope="prototype" parent="BaseEventQuery">-->
    <!--                    <property name="auditType" value="NONE" />-->
    <!--                    <property name="logicDescription" value="Lucene query for event/document UUIDs" />-->
    <!--                    <property name="mandatoryQuerySyntax">-->
    <!--                        <util:set>-->
    <!--                            <value>LUCENE-UUID</value>-->
    <!--                        </util:set>-->
    <!--                    </property>-->
    <!--                    <property name="connPoolName" value="UUID" />-->
    <!--                </bean>-->
    <!--                <bean scope="prototype" parent="BaseEventQuery">-->
    <!--                    <property name="tableName" value="${error.shard.table.name}" />-->
    <!--                    <property name="dateIndexTableName" value="" />-->
    <!--                    <property name="metadataTableName" value="${error.metadata.table.name}" />-->
    <!--                    <property name="indexTableName" value="${error.index.table.name}" />-->
    <!--                    <property name="reverseIndexTableName" value="${error.rindex.table.name}" />-->
    <!--                    <property name="auditType" value="NONE" />-->
    <!--                    <property name="logicDescription" value="Lucene query for event/document UUIDs for events that encountered errors at ingest time" />-->
    <!--                    <property name="mandatoryQuerySyntax">-->
    <!--                        <util:set>-->
    <!--                            <value>LUCENE-UUID</value>-->
    <!--                        </util:set>-->
    <!--                    </property>-->
    <!--                    <property name="connPoolName" value="UUID" />-->
    <!--                </bean>-->
    <!--            </list>-->
    <!--        </property>-->
    <!--        <property name="selectorExtractor"><null/></property>-->
    <!--    </bean>-->

    <!--    &lt;!&ndash; Bean configurations for DATAWAVE query table objects. These are-->
    <!--    used in the TableManagerFactory setup and set as the logic class for the-->
    <!--    bridge tables &ndash;&gt;-->


    <!--    <bean id="IndexStatsQuery" parent="baseQueryLogic" scope="prototype"  class="datawave.query.tables.shard.IndexStatsQueryLogic">-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="selectorExtractor"><null/></property>-->
    <!--    </bean>-->

    <!--    <bean id="QueryMetricsQuery" scope="prototype"  parent="BaseEventQuery" class="datawave.query.metrics.QueryMetricQueryLogic">-->
    <!--        <property name="logicDescription" value="Retrieve query metrics based on the given search term(s)" />-->
    <!--        <property name="includeHierarchyFields" value="false" />-->
    <!--        <property name="modelTableName" value="${querymetrics.metadata.table.name}" />-->
    <!--        <property name="modelName" value="NONE" />-->
    <!--        <property name="tableName" value="${querymetrics.shard.table.name}" />-->
    <!--        <property name="dateIndexTableName" value="${querymetrics.dateindex.table.name}" />-->
    <!--        <property name="metadataTableName" value="${querymetrics.metadata.table.name}" />-->
    <!--        <property name="metadataHelperFactory" ref="metadataHelperFactory" />-->
    <!--        <property name="indexTableName" value="${querymetrics.index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${querymetrics.rindex.table.name}" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--    </bean>-->

    <!--    <bean id="EventQuery" scope="prototype"  parent="BaseEventQuery">-->
    <!--        <property name="logicDescription" value="Query the sharded event/document schema, leveraging the global index tables as needed" />-->
    <!--    </bean>-->

    <!--    <bean id="CountQuery" scope="prototype"  parent="BaseEventQuery" class="datawave.query.tables.CountingShardQueryLogic">-->
    <!--        <property name="logicDescription" value="Retrieve event/document counts based on your search criteria"/>-->
    <!--    </bean>-->

    <!--    &lt;!&ndash; Query Logic that implements a discovery type query over the index &ndash;&gt;-->
    <!--    <bean id="DiscoveryQuery" parent="baseQueryLogic" scope="prototype"  class="datawave.query.discovery.DiscoveryLogic">-->
    <!--        <property name="tableName" value="${index.table.name}" />-->
    <!--        <property name="indexTableName" value="${index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${rindex.table.name}" />-->
    <!--        <property name="maxResults" value="-1" />-->
    <!--        <property name="maxWork" value="-1" />-->
    <!--        <property name="modelTableName" value="${metadata.table.name}" />-->
    <!--        <property name="modelName" value="DATAWAVE" />-->
    <!--        <property name="metadataHelperFactory" ref="metadataHelperFactory" />-->
    <!--        <property name="fullTableScanEnabled" value="false" />-->
    <!--        <property name="allowLeadingWildcard" value="true" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="Discovery query that returns information from the index about the supplied term(s)" />-->
    <!--        <property name="selectorExtractor" ref="DatawaveSelectorExtractor" />-->
    <!--    </bean>-->


    <!--    &lt;!&ndash; Query Logic that implements a discovery type query over the index &ndash;&gt;-->
    <!--    <bean id="ErrorDiscoveryQuery" parent="baseQueryLogic" scope="prototype"  class="datawave.query.discovery.DiscoveryLogic">-->
    <!--        <property name="tableName" value="${error.index.table.name}" />-->
    <!--        <property name="indexTableName" value="${error.index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${error.rindex.table.name}" />-->
    <!--        <property name="maxResults" value="-1" />-->
    <!--        <property name="maxWork" value="-1" />-->
    <!--        <property name="modelTableName" value="${metadata.table.name}" />-->
    <!--        <property name="modelName" value="DATAWAVE" />-->
    <!--        <property name="metadataHelperFactory" ref="metadataHelperFactory" />-->
    <!--        <property name="fullTableScanEnabled" value="false" />-->
    <!--        <property name="allowLeadingWildcard" value="true" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="Discovery query that returns information from the ingest errors index about the supplied term(s)" />-->
    <!--        <property name="selectorExtractor" ref="DatawaveSelectorExtractor" />-->
    <!--    </bean>-->

    <!--    <bean id="ErrorCountQuery" scope="prototype"  parent="BaseCountQuery">-->
    <!--        <property name="logicDescription" value="Retrieve counts of errored events based on your search criteria" />-->
    <!--        <property name="tableName" value="${error.shard.table.name}" />-->
    <!--        <property name="metadataTableName" value="${error.metadata.table.name}" />-->
    <!--        <property name="indexTableName" value="${error.index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${error.rindex.table.name}" />-->
    <!--    </bean>-->

    <!--    <bean id="FacetedQuery" parent="BaseEventQuery" scope="prototype" class="datawave.query.tables.facets.FacetedQueryLogic">-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="Faceted search over indexed fields, returning aggregate counts for field values" />-->
    <!--        <property name="facetedSearchType" value="FIELD_VALUE_FACETS" />-->
    <!--        <property name="facetTableName" value="${table.name.facet}" />-->
    <!--        <property name="facetMetadataTableName" value="${table.name.facet.metadata}" />-->
    <!--        <property name="facetHashTableName" value="${table.name.facet.hashes}" />-->
    <!--        <property name="maximumFacetGrouping" value="200" />-->
    <!--        <property name="minimumFacet" value="1" />-->
    <!--        <property name="streaming" value="true" />-->
    <!--        <property name="querySyntaxParsers">-->
    <!--            <map key-type="java.lang.String" value-type="datawave.query.language.parser.QueryParser">-->
    <!--                <entry key="JEXL">-->
    <!--                    <null/>-->
    <!--                </entry>-->
    <!--                <entry key="LUCENE">-->
    <!--                    <bean class="datawave.query.language.parser.jexl.LuceneToJexlQueryParser" />-->
    <!--                </entry>-->
    <!--                <entry key="LUCENE-UUID" value-ref="LuceneToJexlUUIDQueryParser" />-->
    <!--            </map>-->
    <!--        </property>-->
    <!--    </bean>-->

    <!--    <bean id="HitHighlights" parent="baseQueryLogic" scope="prototype"  class="datawave.query.tables.IndexQueryLogic">-->
    <!--        <property name="tableName" value="${shard.table.name}" />-->
    <!--        <property name="metadataTableName" value="${metadata.table.name}" />-->
    <!--        <property name="metadataHelperFactory" ref="metadataHelperFactory" />-->
    <!--        <property name="indexTableName" value="${index.table.name}" />-->
    <!--        <property name="reverseIndexTableName" value="${rindex.table.name}" />-->
    <!--        <property name="queryThreads" value="${index.query.threads}" />-->
    <!--        <property name="fullTableScanEnabled" value="false" />-->
    <!--        <property name="minimumSelectivity" value=".2" />-->
    <!--        <property name="includeDataTypeAsField" value="false" />-->
    <!--        <property name="includeGroupingContext" value="false" />-->
    <!--        <property name="useEnrichers" value="false" />-->
    <!--        <property name="auditType" value="NONE" />-->
    <!--        <property name="logicDescription" value="Fast boolean query over indexed fields, only returning fields queried on" />-->
    <!--        &lt;!&ndash; Determines how many events in the global index lookup will be-->
    <!--        aggregated into a day range &ndash;&gt;-->
    <!--        <property name="eventPerDayThreshold" value="40000" />-->
    <!--        &lt;!&ndash; Determines how many shards in the global index lookup will be-->
    <!--        aggregated into a day range &ndash;&gt;-->
    <!--        <property name="shardsPerDayThreshold" value="${beq.shardsPerDayThreshold}" />-->
    <!--        &lt;!&ndash; The max number of terms AFTER all expansions &ndash;&gt;-->
    <!--        <property name="maxTermThreshold" value="${beq.maxTermThreshold}" />-->
    <!--        &lt;!&ndash; The max query depth &ndash;&gt;-->
    <!--        <property name="maxDepthThreshold" value="${beq.maxDepthThreshold}" />-->
    <!--        &lt;!&ndash; The max unfielded (_ANYFIELD_) expansion per term &ndash;&gt;-->
    <!--        <property name="maxUnfieldedExpansionThreshold" value="${beq.unfieldedExpansionThreshold}" />-->
    <!--        &lt;!&ndash; The max value (regex or range) expansion &ndash;&gt;-->
    <!--        <property name="maxValueExpansionThreshold" value="${beq.valueExpansionThreshold}" />-->
    <!--        &lt;!&ndash; The max value or list expansion for a single field before using an ivarator &ndash;&gt;-->
    <!--        <property name="maxOrExpansionThreshold" value="${beq.orExpansionThreshold}" />-->
    <!--        &lt;!&ndash; The max value or list expansion for a group of ranges against a single field before combining them in an ivarator &ndash;&gt;-->
    <!--        <property name="maxOrRangeThreshold" value="${beq.orRangeThreshold}" />-->
    <!--        &lt;!&ndash; The maximum number of ranges to combine for merged range ivarators against a single field within an or node &ndash;&gt;-->
    <!--        <property name="maxRangesPerRangeIvarator" value="${beq.maxRangesPerRangeIvarator}" />-->
    <!--        &lt;!&ndash; The maximum number of range ivarators allowed for a single field under an or node &ndash;&gt;-->
    <!--        <property name="maxOrRangeIvarators" value="${beq.maxOrRangeIvarators}" />-->
    <!--        &lt;!&ndash; The max value or list expansion for a single field using an FST ivarator &ndash;&gt;-->
    <!--        <property name="maxOrExpansionFstThreshold" value="${beq.orExpansionFstThreshold}" />-->
    <!--        &lt;!&ndash; The max number of splits to divide a range into for the ivarators.  They are run in a pool of threads controlled by the tserver.datawave.ivarator.threads accumulo configuration property which defaults to 100 (IteratorThreadPoolManager). &ndash;&gt;-->
    <!--        <property name="maxFieldIndexRangeSplit" value="${beq.fieldIndexRangeSplit}" />-->
    <!--        &lt;!&ndash; The max number of evaluation pipelines.  They are run in a pool of threads controlled by the tserver.datawave.evaluation.threads accumulo configuration property which defaults to 100 (IteratorThreadPoolManager). &ndash;&gt;-->
    <!--        <property name="maxEvaluationPipelines" value="${beq.evaluationPipelines}" />-->
    <!--        &lt;!&ndash; The max number of non-null evaluated results to cache on each tserver beyond the evaluation pipelines in queue &ndash;&gt;-->
    <!--        <property name="maxPipelineCachedResults" value="${beq.pipelineCachedResults}" />-->
    <!--        &lt;!&ndash; the list of comma delimited hdfs configuration files something like file:///opt/datawave/hadoop-warehouse/conf/core-site.xml,file:///opt/datawave/hadoop-warehouse/conf/hdfs-site.xml&ndash;&gt;-->
    <!--        <property name="hdfsSiteConfigURLs" value="${hdfs.site.config.urls}" />-->
    <!--        &lt;!&ndash; the zookeeper configuration (could be something like file:///opt/datawave/zookeeper-warehouse/conf/zoo.cfg, or the zookeeper list (somehost1:2181,somehost2:2181,â€¦)&ndash;&gt;-->
    <!--        <property name="zookeeperConfig" value="${ivarator.zookeeper.hosts}" />-->
    <!--        &lt;!&ndash; the list of directories in which the ivarator puts its caches (selection always made on tserver side) &ndash;&gt;-->
    <!--        <property name="ivaratorCacheDirConfigs" ref="IvaratorCacheDirConfigs" />-->
    <!--        &lt;!&ndash; the hdfs location where FST's will be stored (see maxOrExpansionFstThreshold above) &ndash;&gt;-->
    <!--        <property name="ivaratorFstHdfsBaseURIs" value ="${ivarator.fst.hdfs.base.uris}" />-->
    <!--        &lt;!&ndash; the size after which a buffer is flushed to a file. &ndash;&gt;-->
    <!--        <property name="ivaratorCacheBufferSize" value="10000" />-->
    <!--        &lt;!&ndash; the max number of open files in an ivarator &ndash;&gt;-->
    <!--        <property name="ivaratorMaxOpenFiles" value="${beq.maxIvaratorOpenFiles}" />-->
    <!--        &lt;!&ndash; the number of keys scanned after which the buffer is flushed to a file. &ndash;&gt;-->
    <!--        <property name="ivaratorCacheScanPersistThreshold" value="100000" />-->
    <!--        &lt;!&ndash; the scan time after which the buffer is flushed to a file. &ndash;&gt;-->
    <!--        <property name="ivaratorCacheScanTimeoutMinutes" value="${query.max.call.time.minutes}" />-->
    <!--        <property name="querySyntaxParsers">-->
    <!--            <map key-type="java.lang.String" value-type="datawave.query.language.parser.QueryParser">-->
    <!--                <entry key="JEXL">-->
    <!--                    <null/>-->
    <!--                </entry>-->
    <!--                <entry key="LUCENE">-->
    <!--                    <bean class="datawave.query.language.parser.jexl.LuceneToJexlQueryParser" />-->
    <!--                </entry>-->
    <!--                <entry key="LUCENE-UUID" value-ref="LuceneToJexlUUIDQueryParser" />-->
    <!--            </map>-->
    <!--        </property>-->
    <!--        <property name="selectorExtractor" ref="DatawaveSelectorExtractor" />-->
    <!--    </bean>-->

    <!--    <bean id="queryLogicFactory" scope="prototype" class="datawave.webservice.query.logic.QueryLogicFactoryImpl" >-->
    <!--        <property name="queryLogicFactoryConfiguration" ref="QueryLogicFactoryConfiguration" />-->
    <!--    </bean>-->

    <!--    <bean id="queryMetricHandler" scope="prototype" class="datawave.query.metrics.ShardTableQueryMetricHandler">-->
    <!--        <property name="queryLogicFactory" ref="queryLogicFactory"/>-->
    <!--    </bean>-->

    <!--    &lt;!&ndash;-->
    <!--        Factory method config for creating whatever model we want for the default.-->
    <!--        Provides a fall-back model in the event that the named query model 'modelName'-->
    <!--        isn't defined in Accumulo for whatever reason...-->
    <!--    &ndash;&gt;-->
    <!--    <bean id="edgeEventQueryModel" class="datawave.query.model.edge.EdgeQueryModel" factory-method="loadModel">-->
    <!--        <constructor-arg value="/DATAWAVE_EDGE.xml" />-->
    <!--    </bean>-->

    <!--    <bean id="EdgeEventQuery" scope="prototype"  parent="BaseEventQuery" class="datawave.query.tables.edge.DefaultEdgeEventQueryLogic">-->
    <!--        <property name="logicDescription" value="Use results of an EdgeQuery to obtain events/documents that created the given edge" />-->
    <!--        <property name="edgeQueryModel" ref="edgeEventQueryModel" />-->
    <!--        <property name="edgeModelName" value="DATAWAVE_EDGE" />-->
    <!--        <property name="modelTableName" value="${metadata.table.name}" />-->
<!--    <property name="edgeDictionaryProvider" ref="edgeDictionaryProvider" />-->
<!--</bean>-->

<!--<bean id="edgeDictionaryProvider" scope="prototype" class="datawave.webservice.edgedictionary.RemoteEdgeDictionary" />-->



</beans>
